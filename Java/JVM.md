# JVM

> 一次编译，到处运行。 

![](img\352511-20170810232429980-107444580.png)



一个java代码是如何运行起来的：

![](img\352511-20170810232431105-2080375000.png)



### JVM的基本结构

![](img\352511-20170810232433792-373676900.png)

内存空间：

内存空间包括了方法区、Java堆，Java栈和本地方法栈；

方法区：线程共享，存放类信息，变量，静态常量；

Java堆：线程共享，存放类的实例，如果系统产生较多的类，有可能发生OutOfMemoryError异常；

Java栈：单个线程私有，生命周期与线程一致，一个线程对应一个栈，每执行一个方法就往栈中加入一个元素，这个元素称为“栈帧”。栈帧中包含局部变量，用于存放中间状态值的操作栈。当一个递归方法一直递归的话，就可能会产生StackOverflowError异常。

本地方法栈：

和java栈类似，实现操作系统、硬件的交互的目的。

PC寄存器:

调度指令的执行顺序。

执行引擎：

根据PC寄存器的顺序执行程序指令。



## 内存模型

Java栈中的线程有时也需要进行通信，但每个进程都在独立的栈中，所以需要借助于线程共享的Java堆，每个线程相当于都有一个自己的工作内存，而Java堆就相当于一个主内存，主内存中有实例化的对象和数组元素等。

假设我们现在有两个线程，线程一需要改变主存中的X，而线程二需要读取主存中的X，按序进行，进程需要进行两个步骤，在自己的工作内存中进行store操作，在主存中write操作，之后线程二开始动作，在主存中read，在自己的工作内存中进行load操作。

![](img\内存模型.png)

（图片是笔者自己画的，可能不太准确，只为了便于理解）



在读写过程中，这里就涉及了一个读写关系，为了保证每个线程都能拿到自己想要的数据，有时需要进行加锁等操作。



**可见性**

收到可见性就要说到volatile这个关键字。这个关键字做了两件事：

1、线程一工作内存中的变量更新会被强制立即写入到主存中。

2、线程二工作内存中变量数据会被强制立即失效，这使线程二中必须从主存中去获取最新的值。

就是保证了，当线程一对变量进行修改后能第一时间被其他的线程知道。

但用了同样也存在不安全因素，我们假设以下场景：主存中有一个值X=0并声明volatile，现在我开10个线程同时去访问这个值，每个线程都执行X+=n（n为任意数值，是个线程都不相同），这样我们同样无法确定最终主存中的X的值，X的值取决于最后一个结束的进程，会告知其他进程数据改变，但这是全部的进程都进行完了，我们并没有等到想要的结果。



### JVM的垃圾回收机制(GC)

> "stop the world"：stop the world会在执行某个立即回收算法时产生，暂时停止Java程序的运行，等算法运行结束后在继续进行。

我们优化JVM的目标就是减少stop the world的时间。

常见的垃圾回收算法有：

引用计数法、标记清除、标记压缩和复制算法。



**引用计数法**

当某个对象被引用时就计数加1，取消引用就减1，当减少为0时被回收。

这个算法原理很简单，而且实现起来也不困难，当频繁的计数也带来了额外的开销，影响程序的性能，而且这个方法无法解决循环引用的问题。1中引用2,2中引用1，那么对象将永远无法被回收。计数会一直增长。



**标记清除**

两个步骤：标记，清除

**标记：** 遍历所有GC roots，并将GC roots中的可及对象标记为存活。

**清除：** 遍历所有对象，清除没有被标记的可及对象。

显然，遍历是个很费时的操作，同时清除操作也会使得内存空间变得不连续，减低利用率。



**标记压缩**

这是在标记清除的基础上增加了压缩内存空间的操作，显然时间会更长，而且Java程序也需要在压缩执行完后才能执行，因为压缩过程中内存地址可能发生变化。



**复制算法**

将内存空间一分为二，回收是将存活的对象复制到另一半空间，然后将原来那一半全部回收。

这样是比标记压缩更简洁，但同时空间利用率低，也无法支持很多对象存在时，原因很简单，就是一半的内存空间可能不够这些对象全部存活。



以上四种方法好像都没法完美的达到我们优化JVM的目的，JVM不单纯的使用特定的算法，而是使用一种叫垃圾回收器的东西。



### 垃圾回收器

堆内存中也分为新生代和老年代，GC机制主要就是针对这些空间进行，当然元数据区（永久区）也有垃圾回收。

#### 串行回收器

串行回收器是单线程的，对新生代使用复制算法，对老年代使用标记压缩算法。这是最古老最稳定的回收器，但回收时间较长，毕竟串行，而且在执行回收时，应用程序是暂停的。

#### 并行回收器

**1、ParNew回收器**

对新生代使用并行，对老年代使用串行，算法的使用上和串行相同，新复制，老压缩！再多核条件下性能优于串行护回收器。

**2、Parallel回收器**

两种配置：

一：类似于ParNew：新并老串，但这个更注重吞吐量，可认为在相同条件下这种配置优于ParNew。

二：新老均进行并行回收。



#### CMS回收器

并发标记清除，它可以与应用程序并发、交替执行。但这是一种针对老年代的回收器，对新生代没有作用。

他的运行机制是比较复杂的，大致可分为：

1、初始标记：标记从GC Root可直接到达的对象。

2、并发标记(和应用程序线程一起)：主要标记过程，标记全部对象

3、重新标记：由于并发标记时应用程序也在运行，所以要重新标记，进行修正。

4、并发清除(和用户线程一起)：基于标记目标进行清除对象。

减少了应用程序的停顿时间，使用这个回收器不好的一点就是每次清理都不彻底，这使得回收器可能一直处于工作状态，影响程序的吞吐量。



#### G1回收器

这个回收器将对空间划分成很多区块，第一时间清理垃圾最多的区块。

划分很多区块，回收时减小了内存碎片的产生；G1适用于新生代和老年代而CSM只适用于老年代。